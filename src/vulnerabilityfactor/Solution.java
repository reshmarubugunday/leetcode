package vulnerabilityfactor;
import java.util.*;

/*
Company: Amazon OA
The developers at Amazon IAM are working on identifying vulnerabilities in their key generation process.

The key is represented by an array of n integers, where the i-th integer is denoted by key[i].

The vulnerability factor of the array key is defined as the maximum length of a sub array that has a
Greatest Common Divisor (GCD) greater than 1.

To make at most maxChange modifications to the array, where each modification consists of changing
any one element in the array to any other value.

Your task is to minimize the vulnerability factor of the key after at most maxChange changes.

Input
	•	An integer n: the size of the array.
	•	An array key[] of size n: the encryption key.
	•	An integer maxChange: the maximum number of elements that can be changed.

Output
	•	Return an integer: the least possible vulnerability factor of the key.

Constraints
	•	1 ≤ n ≤ 10⁵
	•	0 ≤ maxChange ≤ n
	•	1 ≤ key[i] ≤ 10⁹

Example:
i/p
key = [2, 2, 4, 9, 6]
maxChange = 1
o/p
2

Explanation:
The length of the array is n = 5
Some possible changes:
	1.	Change the first element to 3:
        key = [3, 2, 4, 9, 6]
        Subarrays with GCD > 1: [2, 4] and [9, 6] → length 2.
	2.	Change third element to 5:
        key = [2, 2, 5, 9, 6]
        Subarrays with GCD > 1: [2, 2] and [9, 6] → length 2.

Hence, minimum possible vulnerability factor is 2.
*/

public class Solution {

    // Now the input key is provided as a List<Integer>
    public static int findMinVulnerability(List<Integer> key, long maxChange) {
        int n = key.size();

        // Map each prime factor to the list of indices where it divides key.get(i)
        Map<Integer, List<Integer>> primeIndices = new HashMap<>();
        for (int i = 0; i < n; i++) {
            List<Integer> factors = factorize(key.get(i));
            for (int p : factors) {
                primeIndices.computeIfAbsent(p, k -> new ArrayList<>()).add(i);
            }
        }

        // For each prime, group consecutive indices into intervals.
        // Each interval is represented as a List<Integer> of two elements: [start, end].
        List<List<Integer>> intervals = new ArrayList<>();
        for (List<Integer> indices : primeIndices.values()) {
            Collections.sort(indices);
            int start = indices.getFirst();
            int prev = start;
            for (int i = 1; i < indices.size(); i++) {
                int curr = indices.get(i);
                if (curr != prev + 1) {
                    intervals.add(Arrays.asList(start, prev));
                    start = curr;
                }
                prev = curr;
            }
            intervals.add(Arrays.asList(start, prev));
        }

        // Binary search for the minimal vulnerability factor M.
        int low = 0, high = n;
        int ans = n;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (canAchieve(mid, intervals, n, maxChange)) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return ans;
    }

    /**
     * Checks whether a candidate vulnerability factor M is achievable by placing
     * at most maxChange increments.
     * For an interval [start, end] of length L, we need at least floor(L/(M+1)) breakpoints.
     * One breakpoint (increment) may serve for multiple intervals.
     */
    public static boolean canAchieve(int M, List<List<Integer>> intervals, int n, long maxChange) {
        boolean[] used = new boolean[n];  // Marks indices where an increment is applied.
        long incrementsUsed = 0;

        // Sort intervals by their end index (the second element in each List)
        intervals.sort(Comparator.comparingInt(a -> a.get(1)));

        for (List<Integer> interval : intervals) {
            int start = interval.get(0);
            int end = interval.get(1);
            int length = end - start + 1;
            int required = length / (M + 1);  // floor division

            // Count how many increments have already been placed in this interval.
            int count = 0;
            for (int pos = start; pos <= end; pos++) {
                if (used[pos]) count++;
            }

            int needed = required - count;
            if (needed <= 0) continue;

            // Place additional increments starting from the rightmost position
            // to maximize reuse in overlapping intervals.
            for (int pos = end; pos >= start && needed > 0; pos--) {
                if (!used[pos]) {
                    used[pos] = true;
                    incrementsUsed++;
                    needed--;
                    if (incrementsUsed > maxChange) {
                        return false;
                    }
                }
            }
        }
        return incrementsUsed <= maxChange;
    }

    /**
     * Factorizes num and returns its prime factors as a sorted List<Integer>.
     * This simple trial-division method works for moderate values of num.
     */
    public static List<Integer> factorize(int num) {
        List<Integer> factors = new ArrayList<>();
        int x = num;
        for (int i = 2; i * i <= x; i++) {
            if (x % i == 0) {
                factors.add(i);
                while (x % i == 0) {
                    x /= i;
                }
            }
        }
        if (x > 1) {
            factors.add(x);
        }
        Collections.sort(factors);
        return factors;
    }

    public static void main(String[] args) {
        // Example 1 from the screenshots
        List<Integer> key1 = List.of(4, 2, 4);
        int maxChange1 = 1;
        System.out.println("Sample Output 1: " + findMinVulnerability(key1, maxChange1)); // Expected: 1

        // Example 2 from the screenshots
        List<Integer> key2 =  List.of(5, 10, 20, 10, 15, 5);
        int maxChange2 = 2;
        System.out.println("Sample Output 2: " + findMinVulnerability(key2, maxChange2)); // Expected: 2

        // Example 3 from the explanation (not tested in HackerRank)
        List<Integer> key3 =  List.of(2, 2, 4, 9, 6);
        int maxChange3 = 1;
        System.out.println("Sample Output 3: " + findMinVulnerability(key3, maxChange3)); // Expected: 2
    }

}